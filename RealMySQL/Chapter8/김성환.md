### MYSQL 기준으로 답변해주세요

- 인덱스가 무엇이고, 왜 사용하는지 설명해 주세요.
  - 인덱스는 데이터베이스의 검색을 빠르게 하기 위한 자료구조 입니다. MYSQL의 경우 특정 컬럼 값을 기준으로 정렬된 구조(B-Tree)로 저장되어있어[컬럼 값을 변경하지 않습니다.] 데이터베이스 전체를 보지 않고 원하는 항목의 위치를 빠르게 찾을 수 있도록 도와줍니다.
  - 인덱스를 쓰는 이유는 랜덤 디스크 I/O를 줄일 수 있기 때문입니다. 데이터베이스 서버는 랜덤 디스크 I/O 가 자주 일어납니다(데이터 삽입,수정,검색,삭제 등등). 특정 값을 찾기위해 필요없는 값에 대한 디스크 I/O 가 많으면 성능 저하가 일어납니다. 하지만 인덱스를 사용하면 특정 값을 찾기위해 불필요 한 값을 읽는 횟수가 줄어들고 랜덤 디스크 I/O를 줄 일 수 있습니다.
- B-Tree에 대해 설명해 주세요
  - B-Tree 는 데이터를 밸런스있게 관리하는 인덱싱 알고리즘 입니다.
  - 칼럼의 원래 값을 변형 시키지 않고 정렬된 상태로 유지시킵니다.
  - 구조는 루트 노드 - Branch node - leaf node 로 이루어져 있습니다. 데이터 베이스에서 인덱스와 실제 값은 따로 저장되는데 leaf node의 경우 실제 데이터 레코드를 찾아가기 위해 주소값을 가지고 있습니다.
  - 추가적으로 데이터베이스에서 저장된 실제 값은 랜덤하게 저장되어 있습니다. 그래서 랜덤 I/O가 일어납니다.
- 선택도(기수성)가 무엇이고, 인덱스 설계에 어떤 영향을 주나요
  - 선택도(기수성)란 인덱스 키 값을 가지고 있는 값중 유니크한 값의 수를 의미합니다.
  - 데이터에서 유니크한 값의 수가 5이면(ex. 1 2 3 4 5 1 2 4 1 2 3 4 5) 선택도는 5 입니다.
  - 선택도가 높을 수록 검색 대상이 줄어들어서 빠르게 처리됩니다.
  - 선택도가 낮을 수록 불필요한 데이터를 읽어야 해서(단 1건의 데이터를 찾는다고 하면) 쿼리 효율이 낮아집니다.
- 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. InnoDB의 인덱스 삽입, 삭제, 수정 방식과 같이 설명해 주세요
  - 인덱스를 순회하면서 인덱스 키가 삽입될 위치를 찾고 삽입 시킵니다. 리프노트 테이블이 가득 차면 리프 노드가 분리 되서 상위 브랜치 노드까지 범위가 넒어 집니다.
  - 키 값이 저장된 B-Tree에 삭제 마킹을 합니다. 나중에 mysql 서버가 알아서 처리합니다.
  - 삭제후 삽입하는 형태로 수정이 진행됩니다.
  - InnoDB 의 경우 삽입을 지연시켜 나중에 처리할 수도 있습니다. 단 PK나 유니크 키에 대해선 즉각 실행합니다. 수정과 삭제도 버퍼링되어 지연 처리 될 수도 있습니다.
- B-Tree를 통해서 데이터를 읽는 세가지 방법을 설명해 주세요
  - 인덱스 레인지 스캔
    - 검색해야할 인덱스 범위가 결정되었을 때 사용하는 방식입니다. 루트노드부터 검색을 시작해 리프노드까지 들어간뒤 리프 노드의 레코드를 필요할때 까지 쭉 읽습니다. 이때 인덱스 값 이에외 데이터 파일 값이 필요하면 랜덤 디스크 I/O를 통해 값을 가져옵니다.
    - 정리하면 인덱스 탐색 -> 인덱스 스캔 -> 레코드 읽기(선택) 순서로 진행 됩니다.
  - 인덱스 풀 스캔
    - 인덱스의 처음부터 끝까지 모두 읽는 방식입니다. 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫번 째 칼럼이 아닌경우 풀 스캔 방식으로 사용됩니다.
    - ex (name, email, age) 로 인덱스가 걸려있는데 email, age로 검색하는 경우
    - 인덱스에 명시된 컬럼으로만 조건을 처리할 수 있는 경우 사용됩니다. (인덱스 크기는 테이블의 크기보다 작아 효율적) -> 데이터 레코드 까지 읽으면 인덱스 풀스캔을 진행하지 않습니다.
  - 루트 인덱스 스캔(인덱스 스킵 스캔)
    - 리프 노드(페이지)를 읽을때 페이지에서 필요한 값만 읽고 다음 페이지를 읽는 방식입니다. (듬성 듬성하게 읽는 방식)
    - 보통 Max(), Min() 쿼리를 최적화 할때 사용됩니다.
  
### 추가된 문제 
  - ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
    - 인덱스는 기본적으로 정렬되어있는 상태로 저장되어있습니다. Order by에서 인덱스를 타게되면 옵티마이저가 쿼리를 분석해 역순,정순으로 조회를 합니다. 이렇게 되면 오름차순,내림차순에 대한 조회를 빠르게 할 수 있습니다. (조회된 레코드들의 정렬을 따로 할 필요가 없음) 만약 인덱스가 없으면 따로 모아두었다가 정렬을 수행, GroupBy도 마찬가지
  - 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요? 추가적으로 외래키는요?
    - 기본키는 클러스터 키 입니다. 인덱스는 클러스터키와 세컨더리 키로나눌 수 있습니다. 클러스터키의 경우에는 레코드 주소가 저장되어 있어서 레코드 값을 바로 읽을 수 있고 세컨더리 키는 클러스터 키를 저장해 두어서 세컨더리키 -> 클러스터 키로 한번더 조회를해 레코드의 값을 읽습니다.
    - 외래키는 인덱스라고 할 수 있습니다. 외래키 제약이 설정되면 자동으로 연관데는 테이블의 칼럼에 인덱스까지 생성합니다.
    - 추가적으로 외래키의 특징에는 테이블의 변경이 발생하는 경우에만 잠금 경합이 발생한다. '외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합을 발생시키지 않는다'가 있습니다.
  - (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?
    - 인덱스를 타지 않습니다. 멀티 쿼리 인덱스는 앞의 컬럼을 기준으로 정렬되어 있는 형태로 저장되어있습니다. 따라서 인덱스를 탈때로 A 칼럼을 타고 B 컬럼을 타는데 A 조건이 없으면 B조건을 사용하지 않습니다.
  - 가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?
    - 인덱스를 타더라도 옵티마이저가 Table Full Scan 방식이 효율적이라고 판단하면 Table Full Scan 방식으로 조회를 합니다. 예를들어서 테이블에 데이터가 100개 있다고 가정하고 그중 97개의 데이터가 가지는 인덱스가 걸린 특정 컬럼의 값이 "aaaa"라고 하면 해당 컬럼의 조건으로 걸면 옵티마이저가 테이블 풀 스캔을 진행하기도합니다. => 카디널리티가 매우 낮을 때
  - COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정에는 차이가 있나요?
    - COUNT(*) => 전체 row 수를 셈, Null 여부를 따지지 않음, 실제 데이터를 읽지 않아도 됨
    - COUNT(1) => COUNT(*)와 거의 동일한 성능, 모든 row에 1이라는 상수를 대상으로 count
    - COUNT(column) — 해당 컬럼이 NULL이 아닌 row 수, 실제로 데이터를 읽어야함, 인덱스가 없으면 테이블 스캔 발생
  - 유니크 인덱스는 무엇이고 일반 인덱스의 차이는 뭔가요?
    - 유니크 인덱스는 사실상 제약 조건에 가깝습니다. 또한 일반 세컨더리 인덱스는 사실상 구조상 아무런 차이점이 없습니다.  
    - 읽기 : 사실상 "적은" 양의 레코드를 읽는 것이라 성능에 크게 차이가 있지는 않습니다.
    - 쓰기 : 중복된 값이 있는지 확인하는 단계가 추가되어서 읽기, 쓰기 잠금을 사용하고 이때 데드락이 빈번하게 발생합니다. 체인지 버퍼를 쓰지 못해 인덱스의 저장이나 변경보다 느리게 작동됩니다.
    