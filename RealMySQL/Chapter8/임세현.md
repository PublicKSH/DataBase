인덱스가 무엇이고, 왜 사용하는지 설명해 주세요.
인덱스는 책의 목차처럼, 원하는 데이터를 빠르게 찾기 위한 자료구조입니다.

MySQL(InnoDB)에서는 주로 B+Tree 기반 인덱스를 사용하며, 특정 컬럼의 값을 정렬된 트리 구조로 저장합니다.

검색 속도 향상이 주요 목적이며, 정렬, 범위 조회에도 효과적입니다.

장점
빠른 조회 (SELECT)

정렬 최적화 (ORDER BY, GROUP BY)

중복 방지 (유니크 인덱스)

단점
삽입/수정/삭제 시 오버헤드 증가

디스크/메모리 사용량 증가

B-Tree에 대해 설명해 주세요.
InnoDB는 B-Tree 기반으로 인덱스를 저장하며, 트리의 정렬 상태를 항상 유지해야 합니다.
따라서 DML 작업 시 다음과 같은 일이 발생합니다:

(1) 삽입 (INSERT)
알맞은 위치를 찾아 리프 노드에 삽입

노드가 꽉 차면 **Split(분할)**이 발생 → 성능 저하 가능

(2) 수정 (UPDATE)
인덱스 컬럼을 수정하면 기존 인덱스에서 삭제 후 재삽입 필요

즉, DELETE + INSERT로 처리됨 → 비용 큼

(3) 삭제 (DELETE)
인덱스에서 해당 키 제거

하지만 InnoDB는 MVCC 구조를 쓰기 때문에 실제 삭제는 지연될 수 있음 (Purge thread 처리)

→ 수정이 잦은 테이블은 인덱스 유지 비용이 커져서 성능 저하가 발생할 수 있음


선택도(기수성)가 무엇이고, 인덱스 설계에 어떤 영향을 주나요?
선택도는 인덱스 컬럼의 고유값 비율을 의미합니다.
복합 인덱스에서는 선두 컬럼부터 선택도가 높도록 설계

B-Tree를 통해서 데이터를 읽는 세가지 방법을 설명해 주세요.
인덱스 레인지 스캔
인덱스의 특정 범위를 검색하는 방식입니다.
루트 노드부터 리프 노드까지 이동하면서 조건을 만족하는 값을 찾고, 해당 범위의 인덱스를 순차적으로 읽습니다.
인덱스 풀 스캔
인덱스의 처음부터 끝까지 모든 값을 읽는 방식입니다.
쿼리의 조건절에 인덱스의 첫 번째 칼럼이 아닌 다른 칼럼이 사용된 경우에 사용됩니다.
루스 인덱스 스캔
인덱스를 느슨하게 읽는 방식입니다.
GROUP BY 또는 집합 함수를 최적화하는 경우에 사용됩니다.
집합 함수? == MAX(), MIN() 등
인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 넘기고 다음으로 넘어가는 식으로 처리합니다.
인덱스 스킵 스캔
(MySQL 8.0 버전부터 도입된 기능)
WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적을 때 옵티마이저가 인덱스를 효율적으로 사용할 수 있게 해주는 기능입니다.
옵티마이저는 우선 선행 칼럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 선행 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리합니다.


### 추가된 문제 
  - ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
    - 인덱스는 기본적으로 정렬 되어 있기때문에 ORDER BY 및 GROUP BY의 성능이 빠릅니다.
  - 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요? 추가적으로 외래키는요?
    - 맞다고 볼 수 있습니다. 클러스터링 인덱스라고 하는데 기본키를 기준으로 정렬되어 저장됩니다.
    - 클러스터링 인덱스는 레코드 주소를 직접 가지고 있어 데이터를 한번에 조회가 가능하고 다른 세컨더리 인덱스는 이를 한번 더 참조하는 방식입니다

  - (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?
    - 일반적으로 인덱스를 사용하지 않습니다.
    - 복합 인덱스는 왼쪽부터 순차적으로 사용해야 합니다.(정렬의 이점을 사용 불가)
  - 가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?
    - 옵티마이저 실행 계획을 세울 때 전략적으로 동작합니다.
    - 인덱스를 타도 Table Full Scan 과 차이가 없다면 Table Full Scan 한다고 이해했습니다.   
  - COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정에는 차이가 있나요?
    - COUNT(*)	모든 행 카운트 (NULL 포함), 가장 빠름
    - COUNT(1)	*과 동일하게 처리됨 (최적화됨)
    - COUNT(column)	해당 컬럼이 NULL이 아닌 행만 카운트
  - 유니크 인덱스는 무엇이고 일반 인덱스의 차이는 뭔가요?
    - 제약조건이라 생각해도 됨
    - 읽기도 직접적인 성능향상은 없음 -> 동작 자체는 일반 인덱스와 동일하게 작동
    - 쓰기는 유니크 조건을 확인해야하기 때문에 성능 떨어짐 
