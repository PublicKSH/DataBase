인덱스가 무엇이고, 왜 사용하는지 설명해 주세요.
인덱스는 책의 목차처럼, 원하는 데이터를 빠르게 찾기 위한 자료구조입니다.

MySQL(InnoDB)에서는 주로 B+Tree 기반 인덱스를 사용하며, 특정 컬럼의 값을 정렬된 트리 구조로 저장합니다.

검색 속도 향상이 주요 목적이며, 정렬, 범위 조회에도 효과적입니다.

장점
빠른 조회 (SELECT)

정렬 최적화 (ORDER BY, GROUP BY)

중복 방지 (유니크 인덱스)

단점
삽입/수정/삭제 시 오버헤드 증가

디스크/메모리 사용량 증가

B-Tree에 대해 설명해 주세요.
InnoDB는 B-Tree 기반으로 인덱스를 저장하며, 트리의 정렬 상태를 항상 유지해야 합니다.
따라서 DML 작업 시 다음과 같은 일이 발생합니다:

(1) 삽입 (INSERT)
알맞은 위치를 찾아 리프 노드에 삽입

노드가 꽉 차면 **Split(분할)**이 발생 → 성능 저하 가능

(2) 수정 (UPDATE)
인덱스 컬럼을 수정하면 기존 인덱스에서 삭제 후 재삽입 필요

즉, DELETE + INSERT로 처리됨 → 비용 큼

(3) 삭제 (DELETE)
인덱스에서 해당 키 제거

하지만 InnoDB는 MVCC 구조를 쓰기 때문에 실제 삭제는 지연될 수 있음 (Purge thread 처리)

→ 수정이 잦은 테이블은 인덱스 유지 비용이 커져서 성능 저하가 발생할 수 있음


선택도(기수성)가 무엇이고, 인덱스 설계에 어떤 영향을 주나요?
선택도는 인덱스 컬럼의 고유값 비율을 의미합니다.
복합 인덱스에서는 선두 컬럼부터 선택도가 높도록 설계

B-Tree를 통해서 데이터를 읽는 세가지 방법을 설명해 주세요.
인덱스 레인지 스캔
인덱스의 특정 범위를 검색하는 방식입니다.
루트 노드부터 리프 노드까지 이동하면서 조건을 만족하는 값을 찾고, 해당 범위의 인덱스를 순차적으로 읽습니다.
인덱스 풀 스캔
인덱스의 처음부터 끝까지 모든 값을 읽는 방식입니다.
쿼리의 조건절에 인덱스의 첫 번째 칼럼이 아닌 다른 칼럼이 사용된 경우에 사용됩니다.
루스 인덱스 스캔
인덱스를 느슨하게 읽는 방식입니다.
GROUP BY 또는 집합 함수를 최적화하는 경우에 사용됩니다.
집합 함수? == MAX(), MIN() 등
인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 넘기고 다음으로 넘어가는 식으로 처리합니다.
인덱스 스킵 스캔
(MySQL 8.0 버전부터 도입된 기능)
WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적을 때 옵티마이저가 인덱스를 효율적으로 사용할 수 있게 해주는 기능입니다.
옵티마이저는 우선 선행 칼럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 선행 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리합니다.
