> MYSQL 기준으로 답변해주세요
## 인덱스가 무엇이고, 왜 사용하는지 설명해 주세요.
> 인덱스: 데이터베이스에서 검색 성능을 향상시키기 위해 사용하는 자료구조, 특정 컬럼의 값을 빠르게 찾을 수 있도록 도와줌
- 검색 속도 향상
  
  인덱스를 이용하면 `WHERE`절에 만족하는 레코드를 빠르게 찾을 수 있음
  
- 정렬 속도 향상

  `ORDER BY`가 포함된 쿼리를 실행할 때 정렬 비용이 줄어듦
  
- 조인 성능 향상

  인덱스가 존재하면 조인 연산에서 검색 속도가 빨라짐 

## 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. InnoDB의 인덱스 삽입, 삭제, 수정 방식과 같이 설명해 주세요
> 인덱스는 쓰기(`INSERT`, `UPDATE`, `DELETE`) 성능을 저하
- 인덱스는 기본적으로 `B-Tree` 구조로 관리됨. 따라서 데이터 삽입, 수정, 삭제 시 추가적인 작업이 필요 &rarr; 오버헤드 발생
### InnoDB의 인덱스 삽입, 삭제, 수정 방식
- 삽입(`INSERT`)
  - 데이터를 `B-Tree` 구조에 맞게 삽입해야 하므로, 적절한 위치를 찾아 노드를 업데이트
  - 만약 노드가 가득 차면 `페이지 분할(Page Split)`이 발생 &rarr; 오버헤드 발생
- 삭제(`DELETE`)
  - 삭제된 공간은 즉시 제거되지 않고 마킹되며, 일정 조건에서 병합(`merge`)이 수행
  - 페이지 병합이 발생하면 다시 트리를 재구성 &rarr; 오버헤드 발생
- 수정(`UPDATE`)
  - 인덱스 컬럼이 변경되면, 기존 데이터를 삭제하고 새로운 값을 삽입하는 과정이 필요 &rarr; 오버헤드 발생

## 선택도가 무엇이고, 인덱스 설계에 어떤 영향을 주나요
> 선택도(`Selectivity`):  특정 컬럼에서 인덱스가 얼마나 효율적으로 작동할지를 결정하는 지표

```math
선택도 = \frac {고유\,값\,개수}{전체\,행\,개수}
```
- 0에 가까울수록 낮은 선택도

  중복된 값이 많아 인덱스 효율이 떨어짐
  
- 1에 가까울수록 높은 선택도

  인덱스 검색이 효과적

### 인덱스 설계에 미치는 영향
- 선택도가 낮은 컬럼은 단독으로 인덱스를 설정하면 효율이 떨어짐
- 선택도가 높은 컬럼을 우선적으로 인덱스로 설정하는 것이 유리
- 다중 컬럼 인덱스를 만들 경우, 선택도가 높은 컬럼을 앞에 배치하면 성능이 향상

## B-Tree에 대해 설명해 주세요.
> MySQL에서 인덱스를 구성하는 주요 자료구조
### 특징
- 균형 트리(`Balanced Tree`) 구조를 유지하여, 검색, 삽입, 삭제 연산의 시간 복잡도가 $`O(log N)`$
- 루트 노드 &rarr; 중간 노드 &rarr; 리프 노드 구조
- 노드 하나에 여러 개의 키를 저장할 수 있어, 이진 탐색보다 검색 속도가 빠름

## B-Tree를 통해서 데이터를 읽는 세가지 방법을 설명해 주세요
> 데이터 검색 방법은 `인덱스 레인지 스캔`, `인덱스 풀 스캔`, `인덱스 스킵 스캔`

### 인덱스 레인지 스캔 (Index Range Scan)
> 특정 범위(Range) 검색을 수행할 때 사용

- `WHERE` 절에서 `>` `<` `BETWEEN LIKE '값%'` 등의 조건이 사용될 때 발생
- 인덱스를 이용하여 일부 데이터만 탐색하므로 효율적
  
```sql
SELECT * FROM employees WHERE salary BETWEEN 50000 AND 100000;
```

### 인덱스 풀 스캔 (Index Full Scan)
> 전체 인덱스를 탐색하여 데이터를 가져오는 방식

- 테이블이 아닌 인덱스 자체를 읽기 때문에 일반적인 `FULL TABLE SCAN`보다 빠를 수 있음.
- `ORDER BY`가 걸려 있을 때, 인덱스가 정렬된 상태를 유지하고 있으면 추가 정렬 작업 없이 데이터를 반환할 수 있음.

```sql
SELECT * FROM employees ORDER BY salary;
```
### 루트 인덱스 스캔 (Index Skip Scan)
> 인덱스의 일부 값만 건너뛰면서 검색하는 방식

- 다중 컬럼 인덱스에서 선행 컬럼을 사용하지 않고도 검색이 가능
- 단, 모든 경우에서 효율적인 것은 아니며 데이터가 고르게 분포되어 있을 때만 효과적

```sql
SELECT * FROM employees WHERE age > 30;
```
