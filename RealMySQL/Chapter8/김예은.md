## 04.04 (8.1~8.2)
### 인덱스가 무엇이고, 왜 사용하는지 설명해 주세요.

- 데이터베이스 테이블의 검색 성능과 속도를 향상시키기 위한 방법입니다.
- 칼럼의 값과 해당 레코드의 주소를 키-값 쌍으로 매핑하여 정렬된 상태로 저장하는 데이터 구조입니다.
    - 인덱스는 항상 정렬된 상태로 유지되지만, 레코드는 아닙니다.

### B-Tree에 대해 설명해 주세요.

- 데이터베이스의 인덱싱 알고리즘 중 하나입니다.
- 루트 노드, 브랜치 노드, 리프 노드로 구성된 트리입니다.
- 인덱스 키 값은 항상 정렬된 상태로 유지되며, 리프 노드는 실제 데이터 레코드의 주소 값을 가지고 있습니다.
- 장) 데이터 검색 속도가 빠르다. (균형 트리 구조를 유지)
       범위 검색에서 성능이 좋다. (정렬된 데이터 기반 검색)
- 단) 데이터 Insert, update, delete시 성능이 저하된다. (select에서는 성능 good) 
       인덱스 저장 공간이 추가적으로 필요하다. (디스크 공간에 저장)

### 선택도(기수성)가 무엇이고, 인덱스 설계에 어떤 영향을 주나요?

- 선택도는 인덱스 칼럼의 **유니크한 값의 수**라고 할 수 있습니다.
    - 예를들어, 성별 칼럼(남/여) 보다 주민등록번호 (13자리 수)의 선택도가 높다.
- 선택도가 높을수록 인덱스 검색 범위가 좁아져서 검색 성능이 향상됩니다.
- 선택도가 높은 칼럼을 인덱스로 두는 것이 유리합니다.  → 선택도가 낮은 칼럼에 인덱스를 생성하면 검색 효율이 떨어지고 인덱스 크기만 커져서 성능 저하를 야기할 수 있습니다.

### 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. InnoDB의 인덱스 삽입, 삭제, 수정 방식과 같이 설명해 주세요.

- InnoDB는 B-Tree 인덱스를 사용하여 데이터를 관리합니다.
- InnoDB는 **체인지 버퍼**라는 기능을 통해 인덱스 변경 작업을 지연 처리하여 성능을 향상시킵니다.
- **삽입 :** 새로운 키 값을 B-Tree에 저장하고, 리프 노드가 꽉 차면 분리 작업을 수행.
- **삭제 :** 해당 키 값을 찾아서 **삭제 마크**
- **수정 : 키 값을 삭제**한 후 **새로운 키 값을 추가**하는 형태로 처리
- 삽입, 삭제, 수정 작업 모두 체인지 버퍼로 작업 지연 가능합니다.
- 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다.
- 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이기 때문입니다.
- 하지만 InnoDB 스토리지 엔진을 사용할시 체인지 버퍼를 통하여 인덱스를 관리하므로 수정이 잦은 테이블에서도 어느정도 성능을 보장 할 수 있습니다.

### B-Tree를 통해서 데이터를 읽는 세가지 방법을 설명해 주세요.

- **인덱스 레인지 스캔**
    - 인덱스의 **특정 범위**를 검색하는 방식입니다.
    - 루트 노드부터 리프 노드까지 이동하면서 **조건을 만족하는 값**을 찾고, 해당 범위의 인덱스를 **순차적으로 읽습니다.**
- **인덱스 풀 스캔**
    - 인덱스의 처음부터 끝까지 **모든 값을 읽는 방식**입니다.
    - 쿼리의 조건절에 인덱스의 첫 번째 칼럼이 아닌 다른 칼럼이 사용된 경우에 사용됩니다.
- **루스 인덱스 스캔**
    - 인덱스를 느슨하게 읽는 방식입니다.
    - **GROUP BY 또는 집합 함수를 최적화**하는 경우에 사용됩니다.
        - 집합 함수? == MAX(), MIN() 등
    - 인덱스 레인지 스캔과 비슷하게 작동하지만 **중간에 필요치 않은 인덱스 키 값은 넘기고 다음**으로 넘어가는 식으로 처리합니다.
- **인덱스 스킵 스캔**
    - (MySQL 8.0 버전부터 도입된 기능)
    - WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적을 때 옵티마이저가 인덱스를 효율적으로 사용할 수 있게 해주는 기능입니다.
    - 옵티마이저는 우선 선행 칼럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 선행 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리합니다.

### ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.

- 인덱스가 **존재하지 않을 때**
    - MySQL은 먼저 **필터링된 모든 레코드**를 가져온 다음, 메모리 혹은 디스크 에 임시 테이블을 만들어서, 그 테이블에 대해 `ORDER BY` ****또는 `GROUP BY` 연산을 수행합니다.
    - 이 과정은 레코드 수가 많아질수록 **비용이 크고**, 성능이 나빠집니다. 특히 정렬/그룹 연산은 MySQL에서 성능 병목의 주요 원인으로 꼽히기도 합니다.
    
    ```sql
    -- 따로 정렬을 수행해야 함. (레코드가 많을수록 느림)
    SELECT * FROM employees ORDER BY first_name ASC LIMIT 10;
    ```
    
- **정렬된 인덱스가 존재할 때**
    - 예를 들어 ‘first_name’ 테이블에 오름차순 (ASC) 인덱스가 있다면, **포워드 인덱스 스캔**만으로 결과를 바로 가져올 수 있습니다. (역순 (DESC)  : **백워드 인덱스 스캔**으로 가능)
    - `GROUP BY`도 마찬가지로, 인덱스를 활용하면 미리 정렬된 상태로 레코드를 읽으며 그룹핑할 수 있습니다.
    
    ```sql
    -- idx_firstname 가 있으므로 정렬하지 않아도 정순 스캔으로 가능하므로, 정렬 비용이 들지 않음! 
    CREATE INDEX idx_firstname ON employees(first_name ASC);
    SELECT * FROM employees ORDER BY first_name ASC LIMIT 10;
    ```


## 04.08 (8.3~8.10, 8.4(x), 8.5(x))
### 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요? 추가적으로 외래키는요?

- 기본키는 자동으로 **인덱스를 생성**하기 때문에 인덱스라고 볼 수도 있지만, **완전히 동일한 개념은 아닙니다.**
- **기본키**는 데이터의 **무결성을 보장하기 위한 제약 조건**입니다. 즉, 기본키는 중복을 허용하지 않으며, 반드시 **NOT NULL**이어야 합니다.
- 하지만, **인덱스**는 **데이터의 검색 속도를 향상시키기 위한 자료 구조**입니다. MySQL에서는 기본키를 생성하면 자동으로 **클러스터형 인덱스**가 생성되며, 테이블의 실제 데이터는 기본키 순서대로 디스크에 저장됩니다.
- **외래키**는 다른 테이블의 기본키나 유니크 키를 참조하여 **테이블 간의 관계를 명시하는 제약 조건**입니다. 외래키 자체는 자동으로 인덱스를 생성하지 않지만, 성능과 무결성을 위해 **외래키 컬럼에 인덱스를 수동으로 생성하는 것이 좋습니다.**

### (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?

- **탈 수 없습니다.**
- MySQL의 **복합 인덱스는 선두 컬럼부터 순차적으로** 일치해야 사용할 수 있습니다. 즉, (A, B)라는 복합 인덱스가 있을 경우, **A 컬럼에 대한 조건이 없다면 B 컬럼만으로는 해당 인덱스를 사용할 수 없습니다.**
- 이는 인덱스가 **사전처럼 정렬된 구조**를 가지기 때문에, 선두 키를 기반으로 범위를 좁히지 않으면 B 컬럼으로는 검색이 불가능하기 때문입니다.
    - 1장의 1절 같은 느낌!

> [!TIP]
> 단, Oracle에서는 **인덱스 스킵 스캔**을 활용하는 경우가 있지만, MySQL에서는 일반적으로 지원하지 않습니다.

### 가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?

- **인덱스를 사용하는 것이 오히려 느릴 경우**
    - ex) **WHERE 조건이 테이블 전체의 30~40% 이상**을 걸친다면, 인덱스를 타는 것보다 전체 스캔이 더 빠를 수 있습니다.
- **인덱스 조건이 범위를 좁히지 못하는 경우**
    - ex) `WHERE col LIKE '%abc%'` 와 같이 **앞부분** 와일드카드를 사용하면 인덱스가 사용되지 않습니다.
- **함수나 계산식이 컬럼에 적용된 경우**
    - **ex)**`WHERE YEAR(birthdate) = 1990` 같은 쿼리는 인덱스를 사용할 수 없습니다.
    - 인덱스는 컬럼 **자체의 값**으로 범위를 좁히기 때문에, **컬럼이 아닌 함수 결과**는 인덱스에서 찾을 수 없습니다.
- **인덱스 통계 정보의 부정확성**
    - MySQL 옵티마이저는 인덱스 통계를 기반으로 실행됩니다.
    - 이 통계가 오래되었거나 부정확하면 비효율적인 계획을 선택할 수 있습니다. 이 경우 `ANALYZE TABLE` 명령어로 통계를 갱신할 수 있습니다.

### COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정에는 차이가 있나요?

- `COUNT(*)` 는 **NULL 여부와 상관없이** 전체 레코드의 개수를 세며, **실제로는 가장 빠릅니다.** 특히 인덱스를 사용할 수 없는 경우에도 옵티마이저는 최적화된 방식으로 동작합니다.
- `COUNT(1)` 은 `COUNT(*)` 와 유사하게 동작하며, 실제로는 **1이라는 리터럴을 COUNT하는 것**이므로 성능 차이는 거의 없습니다.
- `COUNT(column)` 은 해당 컬럼의 **NULL이 아닌 값만 카운트**합니다. 즉, 특정 컬럼에 NULL이 있는 경우 `COUNT(column)`은 `COUNT(*)`보다 적은 수를 반환합니다.

> [!TIP]
> 일반적으로 MySQL에서는 `COUNT(*)`가 가장 최적화되어 있으며, MyISAM 스토리지 엔진의 경우 **테이블 메타데이터에 총 레코드 수**가 **저장**되어 있어서 `COUNT(*)`는 매우 빠르게 동작합니다. 반면, InnoDB는 저장된 레코드 수를 바로 알 수 없기 때문에 **실제 데이터를 읽으며 COUNT를 수행**합니다.

### 유니크 인덱스는 무엇이고 일반 인덱스의 차이는 뭔가요?

- **유니크 인덱스**
    - 해당 인덱스가 설정된 컬럼에 대해 **중복 값을 허용하지 않는 제약 조건**
    - 즉, 하나의 값만 존재할 수 있고, 삽입이나 갱신 시 중복이 발생하면 오류가 발생합니다.
- **일반 인덱스**
    - 단순히 검색 성능을 높이기 위한 구조
    - **중복된 값이 있어도 무방**합니다.
- MySQL에서는 유니크 인덱스를 생성하면 **자동으로 무결성 제약 조건**이 걸리므로, **데이터의 유일성을 보장해야 하는 경우**에는 유니크 인덱스를 사용해야 합니다.

> [!TIP]
> 유니크 인덱스는 **옵티마이저가** 해당 인덱스를 사용할 때 "이 쿼리는 최대 1건만 반환된다"는 것을 미리 알 수 있기 때문에, **쿼리 최적화에도 도움**이 됩니다.
